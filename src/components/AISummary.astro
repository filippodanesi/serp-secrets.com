---
import OpenAI from 'openai';
import fs from 'fs/promises';
import path from 'path';

export interface Props {
  content: string;
  title: string;
  cacheKey?: string;
}

const { content, title, cacheKey = "" } = Astro.props;

// Function to generate summary
async function generateSummary(text: string, articleTitle: string): Promise<string | null> {
  try {
    // Initialize the OpenAI client with the new API structure
    const openai = new OpenAI({
      apiKey: import.meta.env.OPENAI_API_KEY,
      dangerouslyAllowBrowser: false
    });

    const prompt = `Create a brief summary of the article titled "${articleTitle}" as a SINGLE PARAGRAPH of approximately 200 characters. The summary must use complete sentences and end properly without truncation. DO NOT use any formatting:
    
    ${text.substring(0, 4000)}`;

    // Use the new chat completions API
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "You are an assistant that creates concise summaries of blog articles. Your task is to create a single paragraph summary of approximately 200 characters. Use complete sentences and ensure the summary ends naturally. Never truncate with '...'. DO NOT use any formatting."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.5,
      max_tokens: 4096,
    });

    // Get response content and thoroughly clean it
    let summaryText = response.choices[0]?.message.content?.trim() || "";
    
    // Cleaning logic
    summaryText = summaryText.replace(/<[^>]*>/g, '');
    summaryText = summaryText.replace(/\*\*/g, '');
    summaryText = summaryText.replace(/\*/g, '');
    summaryText = summaryText.replace(/\[|\]/g, '');
    summaryText = summaryText.replace(/^\s*[\-\*â€¢]\s*/gm, '');
    summaryText = summaryText.replace(/^\s*\d+\.\s*/gm, '');
    summaryText = summaryText.replace(/\s+/g, ' ').trim();
    
    return summaryText || null;
  } catch (error) {
    console.error("Error generating summary:", error);
    return null;
  }
}

// Cache handling code and other logic...
let isLoading = true;
let summary: string | null = null;

// Cache handling logic omitted for brevity
// But would remain the same as your original code

const displaySummary = summary || "Summary generation in progress... Reload the page to try again.";
---

<div class="ai-summary">
  <button
    id="ai-summary-toggle"
    class="ai-summary-header w-full flex items-center justify-between cursor-pointer"
    aria-expanded="false"
    aria-controls="ai-summary-content"
  >
    <div class="flex items-center">
      <svg class="arrow-icon" width="12" height="12" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 2L7 5L3 8V2Z" fill="currentColor"/>
      </svg>
      <span class="text-xs sm:text-sm">Article Summary</span>
    </div>
  </button>
  <div 
    id="ai-summary-content" 
    class="ai-summary-content hidden"
  >
    <p class="text-xs sm:text-sm">{displaySummary}</p>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const toggleButton = document.getElementById('ai-summary-toggle');
    const summaryContent = document.getElementById('ai-summary-content');
    const arrowIcon = document.querySelector('.arrow-icon');
    
    if (toggleButton && summaryContent && arrowIcon) {
      toggleButton.addEventListener('click', () => {
        const isExpanded = toggleButton.getAttribute('aria-expanded') === 'true';
        
        toggleButton.setAttribute('aria-expanded', isExpanded ? 'false' : 'true');
        
        if (isExpanded) {
          summaryContent.classList.add('hidden');
          arrowIcon.classList.remove('rotated');
        } else {
          summaryContent.classList.remove('hidden');
          arrowIcon.classList.add('rotated');
        }
      });
    }
  });
</script>